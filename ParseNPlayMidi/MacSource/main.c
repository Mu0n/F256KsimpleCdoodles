////	Copyright (c) 2024 Michael Juneau, anybitfeverdreams@gmail.com////	Permission is hereby granted, free of charge, to any person obtaining a copy//	of this software and associated documentation files (the "Software"), to deal//	in the Software without restriction, including without limitation the rights//	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell//	copies of the Software, and to permit persons to whom the Software is//	furnished to do so, subject to the following conditions:////	The above copyright notice and this permission notice shall be included in//	all copies or substantial portions of the Software.////	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR//	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,//	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE//	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER//	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,//	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE//	SOFTWARE.////    MIDI Player//  Simple python program that opens a MIDI 1.0 .mid file, parses//  its midi command and sets them up in a multitrack structure, ready to be played//  back using an opened midi port. If you're unsure of which port you should use,//  a list of available ports will be printed out upon executing//// version 0.1 - August 11th 2024#include <stdio.h>#include <stdlib.h>#include <string.h>#include "Serial.h"#include "GestaltEqu.h"#include "Timer.h"#include <Files.h>// midispec.c: SYSEX bytes and structures used to load the parsed MIDI#include "midispec.c" // midiportmac.c: 68k Macintosh specific serial port driver opening and setting to 31,250bps#include "midiportmac.c" // verbomac.c: uses mac toolbox to send out a 255 byte message and long value to a //             mac prompt with printf and awaits answer with scanf#include "verbomac.c"// openmidifilemac.c: uses the mac standard file dialog to fetch 'MIDI' and 'MID ' files and open it#include "openmidfilemac.c"#define kQ 0x0D//Structure used to fetch the proper app's A5 during interrupt timetypedef struct {	TMTask atmTask; 	long tmRefCon; //will pass the address of A5 world} TMInfo, *TMInfoPtr;// *** global variables ***Boolean gVerbo = false; //determines if you get a lot of diagnostics messagesHandle gMidiBuf; // Handle to the raw midi buffer data read from a filechar theCSCale[8] = {0x3c, 0x3e, 0x40, 0x41, 0x43, 0x45, 0x47, 0x48}; //MIDI Note On raw bytes for a C scaleOSErr gOSErr; //fetches error codes during mac file reading operationsint trackcount = 0; // #number of tracks detectedbigParsedH theBigList; //Handle to the parsed MIDI data; could be converted to pointerfloat tick = 0; // #millisecond per ticklong gFileSize; //keeps track of how many bytes in the fileshort gFileNum; //file number for opened .mid fileBoolean readyForNextNote = 1; //interrupt-led flag to signal the loop it's ready for the next MIDI eventshort gFormat = 0; //holds the format type for the info provided after loading 0=single track, 1=multitracklong bigDeltaTotal = 0;int bigDeltaCount=0;// Trap used to fetch the address of the app's A5 registerpascal TMInfoPtr GetTMInfo(void)	=0x2E89; TMInfo myTMInfo;// ***function declarations ***void MIDIPlay(void); //creates a loop and parses it. If you want graphics and interface, it has to be put in there while it waits for interruptsvoid detectMIDIStructure(char *); //first pass to read the header and get the number of tracks unsigned int getTotalLeft(void); //gets a count of the total MIDI events that are relevant and left to playvoid playmidi(void); //this is the main loop while midi playback occurs, insert gfx and interface stuff here as well.void wipeBigList(void); //empties out the big structure that holds the parsed MIDI data, gets it ready for a new oneint getAndAnalyzeMIDI(void); //high level function that directs the reading and parsing of the MIDI filevoid parse(int startIndex, Boolean wantCmds); //is used twice to parse the MIDI read file buffer. Once to get the amount of relevant MIDI event, 2nd to allocate and readvoid parseMIDI(void); //assuming a byte buffer that starts with MThd, read all tracks and produce a structure of aMIDIEvent arraysvoid detectStructure(int startIndex); //checks the tempo, number of tracks, etcvoid playCScale(void); //quick test of a C scale using a series of MySendNote separated by 1 secondint findPositionOfHeader(void); //this opens a .mid file and ignores everything until 'MThd' is encounteredvoid sendAME(aMEPtr midiEvent); //the workhorse of MIDIPlay, sends a string of MIDI bytes into the serial portvoid MySendNote(char whichNote); //sends a test note of default volume and pressure according to the note pitch byte of the argumentvoid installTMTask(void); //installs the Time Manager task, used to get microsecond level interrupts with the revised Time Manager of System 6.0.3+pascal void myTask(void); //the interrupt task just sets a flag to indicate it's ready to receive the pending MIDI event in the parsed structure.void totalPrintOut(void);//prints out the entire bigParsed structure for diagnosticsvoid totalReadOut(void);//reads out the entire bigParsed structure for diagnosticsshort isPressed(unsigned short k);// *** function definitions ***//the interrupt task just sets a flag to indicate it's ready to receive the pending MIDI event in the parsed structure.pascal void myTask()	{	long oldA5;	TMInfoPtr recPtr;		recPtr = GetTMInfo();	oldA5 = SetA5(recPtr->tmRefCon);		readyForNextNote = 1;	oldA5 = SetA5(oldA5);	}//installs the Time Manager task, used to get microsecond level interrupts with the revised Time Manager of System 6.0.3+void installTMTask(void)	{	myTMInfo.atmTask.tmAddr = myTask;	myTMInfo.atmTask.tmWakeUp = 0;	myTMInfo.atmTask.tmReserved = 0;	myTMInfo.tmRefCon = SetCurrentA5();	InsTime((QElemPtr) &myTMInfo);	}//sends a test note of default volume and pressure according to the note pitch byte of the argumentvoid MySendNote(char whichNote)	{	char myMessage[3]={0x90,0x00,0x64};	myMessage[1]=whichNote;	myParamBlock.ioParam.ioBuffer = myMessage;		gOSErr = PBWrite(myPBPtr, FALSE);	if(gOSErr == noErr) 		{		if(gVerbo) printf("sending message successful\n");		}	else if(gVerbo)  printf("sending message unsuccesful, code=%d \n",gOSErr);	}//the workhorse of MIDIPlay, sends a string of MIDI bytes into the serial portvoid sendAME(aMEPtr midiEvent)	{	myParamBlock.ioParam.ioReqCount = midiEvent->bytecount;	myParamBlock.ioParam.ioBuffer = midiEvent->msgToSend;	gOSErr = PBWrite(myPBPtr, FALSE);	}	//this opens a .mid file and ignores everything until 'MThd' is encountered	int findPositionOfHeader(void)	{	char targetSequence[] = "MThd";    char *position;    int thePosition = 0;        HLock((Handle)gMidiBuf);    position = (char *)strstr(*gMidiBuf, targetSequence);		if(position != NULL)		{		thePosition = (position - *gMidiBuf);    	HUnlock((Handle)gMidiBuf);		return thePosition;		}	    HUnlock((Handle)gMidiBuf);	printf("Didn't find a MIDI Header\n");	return -1;	}//quick test of a C scale using a series of MySendNote separated by 1 secondvoid playCScale(void)	{	int i=0;		for(i=0; i<8; i++)		{		MySendNote(theCSCale[i]);		Delay(60,nil);		}	}//checks the tempo, number of tracks, etcvoid detectStructure(startIndex)	{    int bpm = 0; // #beat per minute    int ppq = 0; // #ppq read from header    float tick = 0; // #millisecond per tick    long size = 0; //size of midi byte data count    long trackLength = 0; //size in bytes of the current track    int tdiv=0; //time per division in ticks    long i = startIndex; // #main array parsing index    long j=0;    int currentTrack=0; //index for the current track    aTOE* myTOEPtr;        HLock((Handle)gMidiBuf);          if(gVerbo)     	{    	printf("MIDI file header\n");    	printf("-------------\n");        	for(j=i; j<i+4; j++) printf("%c",*(*gMidiBuf+j)); //print the MThd header tag    	printf("\n");    	}    i+=4;        if(gVerbo) printf("size: ");    size =  (long)((Byte)(*(*gMidiBuf+i+3)));    size += (long)((Byte)(*(*gMidiBuf+i+2)))<<8;    size += (long)((Byte)(*(*gMidiBuf+i+1)))<<16;    size += (long)((Byte)(*(*gMidiBuf+i)))<<24;    if(gVerbo) printf("%lu\n",size);	i+=4;        if(gVerbo) printf("format type (0=single track, 1=multitrack): ");    gFormat = (short)(     	           (Byte)((*(*gMidiBuf+i+1)))    			  +(Byte)((*(*gMidiBuf+i))<<8)    			  );    if(gVerbo) printf("%d\n",gFormat);    i+=2;        if(gVerbo) printf("Track count: ");    trackcount = (short)(     	           (Byte)((*(*gMidiBuf+i+1)))    			  +(Byte)((*(*gMidiBuf+i))<<8)    			  );    if(gVerbo) printf("%d\n",trackcount);    i+=2;        if(gVerbo) printf("Time in ticks per division: ");    tdiv = (short)(     	           (Byte)((*(*gMidiBuf+i+1)))    			  +(Byte)((*(*gMidiBuf+i))<<8)    			  );    if(gVerbo) printf("%d\n",tdiv);    //tdiv += (unsigned long)(*(*gMidiBuf+i))<<8;    i+=2;        if(gVerbo) printf("total length in bytes= %ld",gFileSize);    currentTrack=0;       while(currentTrack < trackcount)    	{	    	if(gVerbo) printf("\n******i is at %ld\n",i);	    	currentTrack++;	    		    	if(gVerbo) {	    		printf("\n-------------\n");	        	printf("Track header for track %d\n", currentTrack);	        	for(j=i; j<i+4; j++) printf("%c",*(*gMidiBuf+j)); //print the MTrk tag	        	printf("\n-------------\n");	        	}	    	i+=4;	    		    	trackLength =  (long)((Byte)(*(*gMidiBuf+i+3)));	    	trackLength += (long)((Byte)(*(*gMidiBuf+i+2)))<<8;	    	trackLength += (long)((Byte)(*(*gMidiBuf+i+1)))<<16;	    	trackLength += (long)((Byte)(*(*gMidiBuf+i)))<<24;	    		    	if(gVerbo) 	    		{	    		printf("track length in bytes: %lu",trackLength);	        	printf("\n-------------\n");	        	}	        i+=4;	        	        i+=trackLength;	        	    	if(gVerbo) printf("\n***************i is at %ld\n",i);	     	    	//if(i>40000) break;			    	} //end of parsing all tracks     HUnlock((Handle)gMidiBuf);               //start defining overal sizes in the big list, now that trackcount is known     if((**theBigList).hasBeenUsed == true)       {        wipeBigList();        }     (**theBigList).hasBeenUsed = true;     (**theBigList).trackcount = trackcount;     (**theBigList).TrackEventList = (aTOEPtr) NewPtr(sizeof(aTOE)*trackcount);     if(gVerbo) printf("Size of Big List, has %d elements\n",(**theBigList).trackcount);          for(j=0;j<trackcount;j++)         {        (**theBigList).TrackEventList[j].trackno = j;        (**theBigList).TrackEventList[j].eventcount = 0;        (**theBigList).TrackEventList[j].eventleft = 0;        }     }	          //assuming a byte buffer that starts with MThd, read all tracks and produce a structure of aMIDIEvent arrays// wantCmds is when it's ready to record the relevant commands in an arrayvoid parse(int startIndex, Boolean wantCmds)	{    int bpm = 0; // #beat per minute    int ppq = 0; // #ppq read from header    long size = 0; //size of midi byte data count    long trackLength = 0; //size in bytes of the current track    int format=0; //0=single track, 1=multitrack    int tdiv=0; //time per division in ticks    long i = startIndex; // #main array parsing index    long j=0;    int currentTrack=0; //index for the current track    	long testValue;	    unsigned char last_cmd = 0x00;    unsigned long currentI;    unsigned long nValue, nValue2, nValue3, nValue4, timeDelta;    unsigned char status_byte = 0x00;    unsigned char meta_byte = 0x00;    unsigned long data_byte = 0x00, data_byte2= 0x00, data_byte3 = 0x00, data_byte4= 0x00;        char forWhichChannel = 0x00;    char twoByter[2], threeByter[3];    int TOEindex;        //first pass will find the number of events to keep in the TOE (table of elements)    //and initialize the myParsedEventList, an array of TOE arrays    //second pass will actually record the midi events into the appropriate TOE for each track        HLock((Handle)gMidiBuf);          if(gVerbo)     	{    	printf("MIDI file header\n");    	printf("-------------\n");    	for(j=i; j<i+4; j++) printf("%c",*(*gMidiBuf+j)); //print the MThd header tag    	printf("\n");    	}    i+=4;        if(gVerbo) printf("size: ");    size =  (long)((Byte)(*(*gMidiBuf+i+3)));    size += (long)((Byte)(*(*gMidiBuf+i+2)))<<8;    size += (long)((Byte)(*(*gMidiBuf+i+1)))<<16;    size += (long)((Byte)(*(*gMidiBuf+i)))<<24;    if(gVerbo) printf("%lu\n",size);	i+=4;        if(gVerbo) printf("format type (0=single track, 1=multitrack): ");    format = (unsigned short) ((unsigned char) (*(*gMidiBuf+i))<<8 | (unsigned char)(*(*gMidiBuf+i+1)));    if(gVerbo) printf("%d\n",format);    i+=2;        if(gVerbo) printf("Track count: ");    trackcount = (unsigned short) ((unsigned char) (*(*gMidiBuf+i))<<8 | (unsigned char)(*(*gMidiBuf+i+1)));    if(gVerbo) printf("%d\n",trackcount);    i+=2;       	if(gVerbo) printf("Time in ticks per division: ");    tdiv = (unsigned short) ((unsigned char) (*(*gMidiBuf+i))<<8 | (unsigned char)(*(*gMidiBuf+i+1)));    if(gVerbo) printf("%d\n",tdiv);    //tdiv += (unsigned long)(*(*gMidiBuf+i))<<8;    i+=2;        if(gVerbo) printf("total length in bytes= %ld",gFileSize);    currentTrack=0;            while(currentTrack < trackcount)    	{    	//if it's the second pass, we know how many events we have per track, so allocate ram for it    	if(wantCmds)     		{     		(**theBigList).TrackEventList[currentTrack].trackEvents = (aME*) NewPtr((**theBigList).TrackEventList[currentTrack].eventcount * sizeof(aME));    		}    	if(gVerbo) printf("\n******i is at %ld\n",i);    	currentTrack++;    	    	    	if(gVerbo)     		{    		printf("\n-------------\n");        	printf("Track header for track %d\n", currentTrack);        	for(j=i; j<i+4; j++) printf("%c",*(*gMidiBuf+j)); //print the MTrk tag        	printf("\n-------------\n");        	}    	i+=4;    	    	trackLength =  (long)((Byte)(*(*gMidiBuf+i+3)));    	trackLength += (long)((Byte)(*(*gMidiBuf+i+2)))<<8;    	trackLength += (long)((Byte)(*(*gMidiBuf+i+1)))<<16;    	trackLength += (long)((Byte)(*(*gMidiBuf+i)))<<24;    	    	if(gVerbo)     		{    		printf("track length in bytes: %lu",trackLength);        	printf("\n-------------\n");        	}        i+=4;            	if(gVerbo) printf("\n***************i is at %ld\n",i);	         	    	last_cmd = 0x00;    	currentI = i;    	while(i < (trackLength + currentI))    		{    		nValue = 0x00000000;    		nValue2 = 0x00000000;    		nValue3 = 0x00000000;    		nValue4 = 0x00000000;    		data_byte = 0x00000000;    		    		    		status_byte = 0x00;    		forWhichChannel = 0x00;			nValue += (Byte)(*(*gMidiBuf+i));			i++;			if(nValue & 0x00000080)				{				nValue &= 0x0000007F;				nValue <<= 7;				nValue2 += (Byte)(*(*gMidiBuf+i));				i++;				if(nValue2 & 0x00000080)					{					nValue2 &= 0x0000007F;					nValue2 <<= 7;					nValue <<= 7;					nValue3 += (Byte)(*(*gMidiBuf+i));					i++;					if(nValue3 & 0x00000080)						{						nValue3 &= 0x0000007F;						nValue3 <<= 7;						nValue2 <<= 7;						nValue <<= 7;						nValue4 += (Byte)(*(*gMidiBuf+i));						i++;						} //end of getting to nValue4					} //end of getting to nValue3				} //end of getting to nValue2	    		timeDelta = nValue | nValue2 | nValue3 | nValue4;    	    	if(timeDelta > 0x0F)    		{    		i++;    		i--;    		}    		//status byte or MIDI message reading    		status_byte = (Byte)(*(*gMidiBuf+i));			i++;					//first, check for run-on commands that don't repeat the status_byte			if(status_byte < 0x80)				{				status_byte = last_cmd;				i--; //go back 1 spot so it can read the data properly				}						//second, deal with MIDI meta-event commands that start with 0xFF			if(status_byte == 0xFF)				{				meta_byte = (Byte)(*(*gMidiBuf+i));				i++;				if(meta_byte == MetaSequence)					{					i+=2;					}				else if(meta_byte == MetaText)					{					data_byte = (Byte)(*(*gMidiBuf+i)); //length of text					i+=(int)data_byte + 1;					}				else if(meta_byte == MetaCopyright)					{					data_byte = (Byte)(*(*gMidiBuf+i)); //length of text					i+=(int)data_byte + 1;					}				else if(meta_byte == MetaTrackName)					{					data_byte = (Byte)(*(*gMidiBuf+i)); //length of text					i+=(int)data_byte + 1;					}				else if(meta_byte == MetaInstrumentName)					{					data_byte = (Byte)(*(*gMidiBuf+i)); //length of text					i+=(int)data_byte + 1;					}				else if(meta_byte == MetaLyrics)					{					data_byte = (Byte)(*(*gMidiBuf+i)); //length of text					i+=(int)data_byte + 1;					}				else if(meta_byte == MetaMarker)					{					data_byte = (Byte)(*(*gMidiBuf+i)); //length of text					i+=(int)data_byte + 1;					}				else if(meta_byte == MetaCuePoint)					{					data_byte = (Byte)(*(*gMidiBuf+i)); //length of text					i+=(int)data_byte + 1;					}				else if(meta_byte == MetaChannelPrefix)					{					i+=2;					}				else if(meta_byte == MetaChangePort)			    	{			    	i+=2;			    	}				else if(meta_byte == MetaEndOfTrack)					{					i++;					if(gVerbo) printf("\n----------- END OF TRACK\n");					continue;					}				else if(meta_byte == MetaSetTempo)					{					data_byte = (Byte)(*(*gMidiBuf+i));					i++;					data_byte2 = (Byte)(*(*gMidiBuf+i));					i++;					data_byte3 = (Byte)(*(*gMidiBuf+i));					i++;					data_byte4 = (Byte)(*(*gMidiBuf+i));					i++;										//version in positive milliseconds					//bpm = 6E7/((data_byte2 << 16) | (data_byte3 << 8) | (data_byte4));					//tick = 60000.0f/(bpm* tdiv);										//version in positive 1/60ths of a second					//bpm = 6E7/((data_byte2 << 16) | (data_byte3 << 8) | (data_byte4));					//tick = 3600.0f/(bpm* tdiv);										//version in negative microseconds					bpm = 6E7/((data_byte2 << 16) | (data_byte3 << 8) | (data_byte4));					tick = 6E7/bpm;					tick = tick/tdiv;										}				else if(meta_byte == MetaSMPTEOffset)					{					i+=6;					}				else if(meta_byte == MetaTimeSignature)					{					i+=5;					}				else if(meta_byte == MetaKeySignature)					{					i+=3;					}				else if(meta_byte == MetaSequencerSpecific)					{					continue;					}			    				else printf("\nUnrecognized MetaEvent %d %d\n",status_byte,meta_byte);				} //end if for meta events			//Third, deal with regular MIDI commands						//MIDI commands with only 1 data byte			//Program change   0xC_			//Channel Pressure 0xD_			else if(status_byte >= 0xC0 && status_byte <= 0xDF)				{				if(wantCmds == false) //merely counting here					{					(**theBigList).TrackEventList[currentTrack-1].eventcount++;					}				if(wantCmds) //prep the MIDI event					{					TOEindex = (**theBigList).TrackEventList[currentTrack-1].eventleft; //where to put this event					(**theBigList).TrackEventList[currentTrack-1].trackEvents[TOEindex].bytecount = 2;										(**theBigList).TrackEventList[currentTrack-1].trackEvents[TOEindex].deltaToGo = (long)tick * (timeDelta);					(**theBigList).TrackEventList[currentTrack-1].trackEvents[TOEindex].msgToSend[0] = status_byte;					(**theBigList).TrackEventList[currentTrack-1].trackEvents[TOEindex].msgToSend[1] = (Byte)(*(*gMidiBuf+i));										(**theBigList).TrackEventList[currentTrack-1].eventleft++; //add 1 to the current index for next event if any is found during the next loop pass															if((**theBigList).TrackEventList[currentTrack-1].trackEvents[TOEindex].deltaToGo>0)						{						bigDeltaTotal+= (**theBigList).TrackEventList[currentTrack-1].trackEvents[TOEindex].deltaToGo;						bigDeltaCount++;						}					}				i++; //advance the index either way				} //end of prg ch or chan pres							//MIDI commands with 2 data bytes			// Note off 0x8_			// Note on  0x9_			// Polyphonic Key Pressure 0xA_ (aftertouch)			// Control Change 0xB_			// (0xC_ and 0xD_ have been taken care of above already)			// Pitch Bend 0xE_			else if((status_byte >= 0x80 && status_byte <= 0xBF) || (status_byte >= 0xE0 && status_byte <= 0xEF))				{				if(wantCmds == false) //merely counting here					{					(**theBigList).TrackEventList[currentTrack-1].eventcount++;					}				if(wantCmds) //prep the MIDI event					{					TOEindex = (**theBigList).TrackEventList[currentTrack-1].eventleft; //where to put this event					(**theBigList).TrackEventList[currentTrack-1].trackEvents[TOEindex].bytecount = 3;										(**theBigList).TrackEventList[currentTrack-1].trackEvents[TOEindex].deltaToGo = (long)tick * (timeDelta);					(**theBigList).TrackEventList[currentTrack-1].trackEvents[TOEindex].msgToSend[0] = status_byte;					(**theBigList).TrackEventList[currentTrack-1].trackEvents[TOEindex].msgToSend[1] = (Byte)(*(*gMidiBuf+i));					(**theBigList).TrackEventList[currentTrack-1].trackEvents[TOEindex].msgToSend[2] = (Byte)(*(*gMidiBuf+i+1));					(**theBigList).TrackEventList[currentTrack-1].eventleft++; //add 1 to the current index for next event if any is found during the next loop pass					if((**theBigList).TrackEventList[currentTrack-1].trackEvents[TOEindex].deltaToGo>0)						{						bigDeltaTotal+= (**theBigList).TrackEventList[currentTrack-1].trackEvents[TOEindex].deltaToGo;						bigDeltaCount++;						}					}				i+=2; //advance the index either way				}// end of 3-data-byter events    		else    			{    			printf("\n ---Unrecognized event sb=",status_byte);    			}    		last_cmd = status_byte;    		    		} //end of parsing a track    	} //end of parsing all tracks        HUnlock((Handle)gMidiBuf);     }	 //end of parse function          //high level function that directs the reading and parsing of the MIDI file     int getAndAnalyzeMIDI(void)	{	int indexToStart=0; //MThd should be at position 0, but it might not, so we'll find it		gFileNum = openMIDIFile(); //actual process of asking for a midi file through std mac dialog	indexToStart = findPositionOfHeader(); //find the start index of 'MThd'	if(gVerbo) printf("Had to skip %d bytes to find MIDI Header tag\n",indexToStart);	if(indexToStart == -1)		{		printf("ERROR: couldn't find a MIDI header in your file; it might be invalid\n");		return -1;		}	detectStructure(indexToStart); //parse it a first time to get the format type and nb of tracks		return indexToStart;	}void wipeBigList(void)	{	int i = 0, nbTracks = 0;	nbTracks = (**theBigList).trackcount;	for(i=0; i< nbTracks; i++) //for every track		{		if((**theBigList).TrackEventList[i].trackEvents != NULL) DisposePtr((Ptr)((**theBigList).TrackEventList[i].trackEvents));		(**theBigList).TrackEventList[i].eventcount=0;		(**theBigList).TrackEventList[i].eventleft=0;		}	if((**theBigList).TrackEventList != NULL) DisposePtr((Ptr)((**theBigList).TrackEventList));	(**theBigList).trackcount=0;	}short isPressed(unsigned short k)	{	unsigned char km[16];		GetKeys((long *)km);	return (( km[k>>3] >> (k&7) ) &1);	}	void playmidi(void)	{	KeyMap theKeys;	int i,j;	int endToIt = 200;	int lowestTrack=0, currentIndex=0;	int localTotalLeft=0;	unsigned int lowestEventIndex;	long lowestTimeFound = 50000000;	int trackcount = (**theBigList).trackcount;	Boolean exitFlag = false;		gPortGreenFlag=true;	printf("\nCurrently playing\n");	if(theBigList == NULL || !gPortGreenFlag) return; 	HLock((Handle)theBigList);		localTotalLeft = getTotalLeft();	while(localTotalLeft > 0 && !exitFlag)		{		// *** OPTIONAL ***		//cheap note count limiter for really slow midi files while debugging		//endToIt--;		//if(endToIt == 0) return;		// *** ***								//keyb input events 				GetKeys(theKeys);		if(isPressed(kQ)) exitFlag = true;							//For loop attempt to find the most pressing event with the lowest time delta to go		for(i=0; i<trackcount; i++)			{			if((**theBigList).TrackEventList[i].eventleft == 0) continue; //this track is exhausted, go to next						currentIndex = (**theBigList).TrackEventList[i].eventcount-(**theBigList).TrackEventList[i].eventleft; //get where we at with this delta			if((**theBigList).TrackEventList[i].trackEvents[currentIndex].deltaToGo < lowestTimeFound) 				{				lowestTimeFound = (**theBigList).TrackEventList[i].trackEvents[currentIndex].deltaToGo;				lowestTrack = i; //new record in this track				lowestEventIndex = currentIndex;				}			if(lowestTimeFound == 0) break; //not gonna find a more imminent event			}  //end of the for loop for most imminent event				//Do the event				if(lowestTimeFound==0) //do these 0 delay events right away, no need to involve a Time Manager			{			sendAME(&((**theBigList).TrackEventList[lowestTrack].trackEvents[lowestEventIndex]));			readyForNextNote = 1;						}		else { //for all the rest which have a time delay						readyForNextNote = 0;			PrimeTime((QElemPtr)&myTMInfo,-lowestTimeFound);			//cheapo delay mechanism here, must be replaced later for asynchronous play			while(readyForNextNote == 0);						sendAME(&((**theBigList).TrackEventList[lowestTrack].trackEvents[lowestEventIndex]));					}				//old deprecated way to use 16.67 ms multiples (ticks) - too slow for MIDI//		Delay(lowestTimeFound/16667,nil);						//Advance the marker for the track that just did something, if there's more left		if((**theBigList).TrackEventList[lowestTrack].eventleft > 0)			{			(**theBigList).TrackEventList[lowestTrack].eventleft--;			}		//lower every other pending events with the time delta we just did, this is destructive 		if(lowestTimeFound >0)			{			for(i=0;i<trackcount;i++)				{				if(i==lowestTrack) continue; //lower all others, but not the one we just did				if((**theBigList).TrackEventList[i].trackEvents[currentIndex].deltaToGo == 0) continue;							currentIndex = (**theBigList).TrackEventList[i].eventcount-(**theBigList).TrackEventList[i].eventleft; //get where we at with this delta				(**theBigList).TrackEventList[i].trackEvents[currentIndex].deltaToGo -= lowestTimeFound;				}			}		lowestTimeFound = 50000000; //make it easy to find lower for next pass		localTotalLeft--;		}	HUnlock((Handle)theBigList);	}		//gets a count of the total MIDI events that are relevant and left to play	unsigned int getTotalLeft(void)	{	int sum=0;	int i=0;	int tc = (**theBigList).trackcount;	for(i=0; i<tc; i++)		{		sum+=(**theBigList).TrackEventList[i].eventleft;		}	return sum;	}		void totalPrintOut(){int i, imax; //trackcount indexint j, jmax; //eventcount indexint k, kmax; //bytecount indexlong wC; //used to direct how many bytes to write every chunkshort fRef, rc; //file ref number for writingCreate("\pyodoods",0,'????','DMID');rc = FSOpen("\pyodoods",0, &fRef);imax = (**theBigList).trackcount;printf("%d ",imax);wC=2;FSWrite(fRef,&wC,&imax);for(i=0;i<imax;i++) //loop over every track	{	jmax=(**theBigList).TrackEventList[i].eventcount;		printf("%d ",jmax);	wC=2;	FSWrite(fRef,&wC,&jmax);		for(j=0;j<jmax;j++) //loop over every event		{		kmax = (**theBigList).TrackEventList[i].trackEvents[j].bytecount;				//printf("%lu ",(**theBigList).TrackEventList[i].trackEvents[j].deltaToGo);		wC=4;		FSWrite(fRef,&wC,&((**theBigList).TrackEventList[i].trackEvents[j].deltaToGo));				//printf("%d ",kmax);		wC = 2;		FSWrite(fRef,&wC,&kmax);				for(k=0; k<kmax; k++) //loop over every event byte			{			//printf("%c ",(**theBigList).TrackEventList[i].trackEvents[j].msgToSend[k]);			wC=1;			FSWrite(fRef,&wC,&((**theBigList).TrackEventList[i].trackEvents[j].msgToSend[k]));			}		} //end loop event	} //end loop trackFSClose(fRef);FlushVol(nil, 0);printf("\n Finished saving the digested/parsed MIDI data");}void totalReadOut(){int i, imax; //trackcount indexint j, jmax; //eventcount indexint k, kmax; //bytecount indexlong rB, delta; //used to direct how many bytes to read every chunkshort fRef, rc; //file ref number for writingchar msgB;long bookkeep =0;//wipeBigList();HLock((Handle)theBigList);rc = FSOpen("\pyodoods",0, &fRef);rB=2;bookkeep+=rB;FSRead(fRef,&rB,(int *)&imax);(**theBigList).trackcount = imax;(**theBigList).TrackEventList = (aTOEPtr) NewPtr(sizeof(aTOE)*imax);printf("\nTrack Count: %d ",imax);(**theBigList).hasBeenUsed = true;for(i=0;i<imax;i++)	{	rB=2;	bookkeep+=rB;	FSRead(fRef,&rB,(int *)&jmax);	printf("\nTrack %d events: %d ",i, jmax); 			(**theBigList).TrackEventList[i].trackno = i;	(**theBigList).TrackEventList[i].eventcount = jmax;	(**theBigList).TrackEventList[i].eventleft = jmax;    (**theBigList).TrackEventList[i].trackEvents = (aME*) NewPtr(jmax * sizeof(aME));	printf("\nRAM reserved for track %d ",i);					for(j=0;j<jmax;j++)		{		rB=4;		bookkeep+=rB;		FSRead(fRef,&rB,(long *)&delta);		(**theBigList).TrackEventList[i].trackEvents[j].deltaToGo = delta;				rB=2;		bookkeep+=rB;		FSRead(fRef,&rB,(int *)&kmax);		(**theBigList).TrackEventList[i].trackEvents[j].bytecount = kmax;						for(k=0;k<kmax;k++)			{			rB=1;			bookkeep+=rB;			FSRead(fRef,&rB,(char *)&msgB);			(**theBigList).TrackEventList[i].trackEvents[j].msgToSend[k] = msgB;							}		}	}	HUnlock((Handle)theBigList);	FSClose(fRef);}void main()	{	Boolean isDone = false;	char answer[80];	char *theMIDFileBuff;	int convNum;	int indexStart;	int j=0;	long gResponse;		MaxApplZone(); 	MoreMasters(); //a mac strategy - bumps up the reserved space for master pointers. doubtful if really necessary	MoreMasters();			theBigList = (bigParsedH)NewHandle(sizeof(bigParsed));	(**theBigList).hasBeenUsed = false;		MyOpenSerialDriver(); //serial port stuff	MyChangeInputBuffer(); //serial port stuff	MySetHandshakeOptions(); //serial port stuff	TweakClock(); //gets us that poorly documented 31.250 kbps speed on the modem serial port	PrepParamBlock();		installTMTask(); //this task will be installed only in the beginning, and reactivated for interrupts with PrimeTime		gOSErr = Gestalt(gestaltTimeMgrVersion,&gResponse);	if(gOSErr !=noErr) printf("\nToo old for Gestalt\n");	else 		{		switch(gResponse)			{			case gestaltStandardTimeMgr:				printf("\nPre 6.0.3 Std Time Manager\n");				break;			case gestaltRevisedTimeMgr:				printf("\nLate System 6 Revised Time Manager\n");				break;			case gestaltExtendedTimeMgr:				printf("\nSys 7+ Extended Time Manager\n");				break;			}		}		while(!isDone)		{		printf("READY for a new command. Type it and press enter\n");		printf("Hex number for note (0=middle C)  |   Numpad + for major C scale test   |   Numpad . for one middle C\n");		printf("Numpad * to fetch a MIDI file and get info   |   p to play a loaded MIDI file\n");		printf("v to get toggle verbose information during operations  |  q to quit, or use the menus\n");		gets(answer);		if(strcmp(answer,"q")==0 || strcmp(answer,"quit")==0) isDone = true;		else if(strcmp(answer,"+")==0) playCScale();		else if(strcmp(answer,"v")==0) 			{			gVerbo = 1;			printf("\nCommands will now be verbose\n");			}		else if(strcmp(answer,"m")==0) 			{			gVerbo = 0;			printf("\nCommands will now be non-verbose\n");			}		else if(strcmp(answer,"s")==0) 			{			gVerbo = 0;			totalPrintOut();			}		else if(strcmp(answer,"r")==0) 			{			gVerbo = 0;			totalReadOut();			}		else if(strcmp(answer,"*")==0) 			{			indexStart = getAndAnalyzeMIDI(); //will ask for a midi file and get its basic info			if(indexStart == -1) continue;			parse(indexStart,false); //count the events and prep the mem allocation for the big list						parse(indexStart,true); //load up the actual event data in the big list			printf("File loaded successfully:\nMIDI Type %d  |   Number of tracks: %d  |  Number of Events to play: %d\n", gFormat, trackcount, getTotalLeft());			    	    			}		else if(strcmp(answer,"p")==0)			{			if(indexStart == -1)				{				printf("load a MIDI file first\n");				continue;				}			playmidi();			FlushEvents(everyEvent,0);			}		else if(strcmp(answer,".")==0) 			{			MySendNote(0x3c);						printf("note sent\n");			}		else			{			convNum = (int)strtol(answer,NULL,16);			convNum += 0x3c;						MySendNote(convNum);			printf("note sent hex number 0x%x or %d detected \n",convNum+0x3c, convNum+0x3c);			}		if(Button()) isDone = true;		}			MyCloseSerialDriver();	wipeBigList();		HUnlock((Handle)theBigList);		RmvTime((QElemPtr) &myTMInfo); //this must happen before the application quits or it will freeze the computer	ExitToShell(); //Go back to Finder	}	